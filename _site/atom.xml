<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>RustyCoin</title>
 <link href="http://www.tomshen.me/rustycoin/atom.xml" rel="self"/>
 <link href="http://www.tomshen.me/rustycoin/"/>
 <updated>2014-05-09T15:42:39-04:00</updated>
 <id>http://www.tomshen.me/rustycoin</id>
 <author>
   <name>Tom Shen</name>
   <email></email>
 </author>

 
 <entry>
   <title>Final Report</title>
   <link href="http://www.tomshen.me/rustycoin/final-report"/>
   <updated>2014-05-09T10:12:00-04:00</updated>
   <id>http://www.tomshen.me/rustycoin/final-report</id>
   <content type="html">&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;In this project, we explored implementation of a &lt;a href=&quot;http://riecoin.org/&quot;&gt;Riecoin&lt;/a&gt; miner in the &lt;a href=&quot;http://www.rust-lang.org/&quot;&gt;Rust programming language&lt;/a&gt;. We implemented a parallel prime cluster finding algorithm to find the proof of work for Riecoin. Our implementation achieves a 23-times speedup over the sequential algorithm on a 24-core Linux machine.&lt;/p&gt;

&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;
&lt;p&gt;Riecoin is a cryptocurrency similar to Bitcoin. New units of currency (called Riecoins) can be produced through the process of mining. Every 2.5 minutes, a new block of currency is available to be mined. In order to mine the block and get the currency, the miner must be able to calculate a proof of work, which generally is a number meeting certain constraints that is difficult to calculate but easy to verify.&lt;/p&gt;

&lt;p&gt;Riecoin’s proof of work is to find a number &lt;em&gt;X&lt;/em&gt; such that &lt;em&gt;basep&lt;/em&gt; + &lt;em&gt;X&lt;/em&gt; is the first prime of a prime cluster, where &lt;em&gt;basep&lt;/em&gt; is a number that varies in size based on the current difficulty, and &lt;em&gt;X&lt;/em&gt; must be in a certain range based on the current difficulty. The &lt;em&gt;difficulty&lt;/em&gt; is adjusted based on how quickly miners were able to mine previous blocks, so that increases in computational power and/or improvements in mining algorithms don’t cause too much inflation. Currently, &lt;em&gt;basep&lt;/em&gt; is around 300 bits long.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;prime cluster&lt;/em&gt; is a sextuplet of primes of the form:
&lt;em&gt;p&lt;/em&gt;, &lt;em&gt;p&lt;/em&gt;+4, &lt;em&gt;p&lt;/em&gt;+6, &lt;em&gt;p&lt;/em&gt;+10, &lt;em&gt;p&lt;/em&gt;+12, &lt;em&gt;p&lt;/em&gt;+16.&lt;/p&gt;

&lt;p&gt;A typical algorithm will sieve a number of smaller primes using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes&quot;&gt;Sieve of Eratosthenes&lt;/a&gt;, then use &lt;a href=&quot;http://en.wikipedia.org/wiki/Wheel_factorization&quot;&gt;wheel factorization&lt;/a&gt; to find likely candidates for proofs of work, and finally check if candidates are valid using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test&quot;&gt;Rabin-Miller primality test&lt;/a&gt;. A more thorough explanation can be found in CMU professor Dave Andersen’s &lt;a href=&quot;http://da-data.blogspot.com/2014/03/fast-prime-cluster-search-or-building.html&quot;&gt;blog post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Wheel factorization can be used to generate candidates because we can show that all proofs of work must fit a certain pattern (though the reverse is not necessarily true). For instance, sieving with small primes can be used to show that all valid proofs of work must be of the form 210&lt;em&gt;n&lt;/em&gt; + 97 (note that 210 is a primorial, the product of primes 2,3,5,7).&lt;/p&gt;

&lt;p&gt;While the initial sieving step is inherently sequential, wheel factorization can be parallelized, since it involves generation of candidates that fit several different patterns. Candidate generation for each pattern is independent, allowing that process to be parallelized. Additionally, the process of verifying proofs of work can trivially be parallelized, since we can check each candidate independently.&lt;/p&gt;

&lt;p&gt;Another opportunity for parallelism is data parallelism: since we are looking for prime clusters within a certain range, we can split that range into several smaller ranges, and search each in parallel.&lt;/p&gt;

&lt;h2 id=&quot;rust&quot;&gt;Rust&lt;/h2&gt;
&lt;p&gt;We decided to work with experimental programming language Rust because it seemed to offer a better approach to systems programming than C++. It’s build from the ground up to be memory safe, which solves one of the major issues with C/C++. Additionally, it was highly influenced by functional programming languages like SML, which means it has very nice features like algebraic data types (e.g. &lt;code&gt;Some(x) / None&lt;/code&gt;), immutability by default, pattern matching, closures, higher-order-functions, and type inference. We expected Rust’s functional flavor to improve programmer productivity and make reasoning about concurrency easier.&lt;/p&gt;

&lt;h1 id=&quot;approach&quot;&gt;Approach&lt;/h1&gt;
&lt;p&gt;Tell us how your implementation works. Your description should be sufficiently detailed to provide the course staff a basic understanding of your approach. Again, it might be very useful to include a figure here illustrating components of the system and/or their mapping to parallel hardware.&lt;/p&gt;

&lt;p&gt;Describe the technologies used. What language/APIs? What machines did you target?
Describe how you mapped the problem to your target parallel machine(s). IMPORTANT: How do the data structures and operations you described in part 2 map to machine concepts like cores and threads. (or warps, thread blocks, gangs, etc.)
Did you change the original serial algorithm to enable better mapping to a parallel machine?
If your project involved many iterations of optimization, please describe this process as well. What did you try that did not work? How did you arrive at your solution? The notes you’ve been writing throughout your project should be helpful here. Convince us you worked hard to arrive at a good solution.
If you started with an existing piece of code, please mention it (and where it came from) here.&lt;/p&gt;

&lt;h1 id=&quot;results&quot;&gt;Results&lt;/h1&gt;
&lt;p&gt;How successful were you at achieving your goals? We expect results sections to differ from project to project, but we expect your evaluation to be very thorough (your project evaluation is a great way to demonstrate you understood topics from this course). Here are a few ideas:&lt;/p&gt;

&lt;p&gt;If your project was optimizing an algorithm, please define how you measured performance. Is it wall-clock time? Speedup? An application specific rate? (e.g., moves per second, images/sec)
Please also describe your experimental setup. What were the size of the inputs? How were requests generated?
Provide graphs of speedup or execute time. Please precisely define the configurations being compared. Is your baseline single-threaded CPU code? It is an optimized parallel implementation for a single CPU?
Recall the importance of problem size. Is it important to report results for different problem sizes for your project? Do different workloads exhibit different execution behavior?
IMPORTANT: What limited your speedup? Is it a lack of parallelism? (dependencies) Communication or synchronization overhead? Data transfer (memory-bound or bus transfer bound). Poor SIMD utilization due to divergence? As you try and answer these questions, we strongly prefer that you provide data and measurements to support your conclusions. If you are merely speculating, please state this explicitly. Performing a solid analysis of your implementation is a good way to pick up credit even if your optimization efforts did not yield the performance you were hoping for.
Deeper analysis: Can you break execution time of your algorithm into a number of distinct components. What percentage of time is spent in each region? Where is there room to improve?
Was your choice of machine target sound? (If you chose a GPU, would a CPU have been a better choice? Or vice versa.)&lt;/p&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;
&lt;p&gt;Please provide a list of references used in the project.&lt;/p&gt;

&lt;h1 id=&quot;list-of-work-by-each-student&quot;&gt;List of Work by Each Student&lt;/h1&gt;
&lt;p&gt;Equal work was performed by both project members.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Project Checkpoint</title>
   <link href="http://www.tomshen.me/rustycoin/checkpoint"/>
   <updated>2014-04-18T00:00:00-04:00</updated>
   <id>http://www.tomshen.me/rustycoin/checkpoint</id>
   <content type="html">&lt;h1 id=&quot;current-progress&quot;&gt;Current Progress&lt;/h1&gt;
&lt;p&gt;We have completed a sequential Riecoin proof of work algorithm in Rust. The two main components we have implemented are the Rabin-Miller primality test and wheel factorization. These are the algorithms used by David Andersen in his &lt;a href=&quot;https://github.com/dave-andersen/fastrie&quot;&gt;CPU miner&lt;/a&gt;. We researched other methods of prime verification and generation, but it seems that these are the most efficient for the large integers we are dealing with.&lt;/p&gt;

&lt;p&gt;We began by implementing these algorithms for bignums. However, we realized that a lot of the functionality we need for the miner is not yet implemented in the built-in Rust bignum library. For now, our algorithm assumes that we are dealing with unsigned 64 bit integers. In the next week, we plan to add the needed functionality to the bignum library, so that we can handle the large integers needed for the miner.&lt;/p&gt;

&lt;p&gt;Also, we decided to use an external &lt;a href=&quot;https://github.com/jsanders/rust-bignum&quot;&gt;Rust bignum library&lt;/a&gt;, after poor performance on Rabin-Miller with the built-in library. This improved performance on Rabin-Miller substantially. We will be modifying this library, rather than the built-in bignum library.&lt;/p&gt;

&lt;p&gt;We have also written some unit tests for Rabin-Miller and wheel factorization. We will be using the built-in Rust unit testing.&lt;/p&gt;

&lt;h1 id=&quot;challenges&quot;&gt;Challenges&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Modifying the bignum library to include what we need for the proof of work algorithm&lt;/li&gt;
  &lt;li&gt;Doing arithmetic on very large integers&lt;/li&gt;
  &lt;li&gt;Optimizing our proof of work algorithm to beat the CPU implementation by reducing shared information&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;revised-goals&quot;&gt;Revised Goals&lt;/h1&gt;
&lt;p&gt;We are definitely on schedule to complete a proof of work algorithm that uses the GPU and improves upon CPU performance. Now that we have written the sequential algorithm, adapting it to use OpenCL should be easily completed in the next couple weeks. We are also confident that we will be able to optimize our algorithm further by parallelizing additional components of the algorithm. Given our revised schedule below, we should have time to implement a complete Riecoin miner. The only thing that may prevent us from achieving these goals is adding to the bignum library, which may be more difficult than expected.&lt;/p&gt;

&lt;h2 id=&quot;plan-to-achieve&quot;&gt;Plan to achieve&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Add functionality to bignum library&lt;/li&gt;
  &lt;li&gt;Use GPU for parallel prime cluster searching&lt;/li&gt;
  &lt;li&gt;Achieve better performance than CPU miner on a GHC machine&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hope-to-achieve&quot;&gt;Hope to achieve&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Parallelize rest of computation (fast prime verification)&lt;/li&gt;
  &lt;li&gt;Implement complete Riecoin miner&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;remaining-schedule&quot;&gt;Remaining Schedule&lt;/h1&gt;
&lt;p&gt;| Dates             | What We Plan to Do                                                                           |
|——————-|———————————————————————————————-|
| Apr. 17 - Apr. 19 | Complete sequential miner, project checkpoint                                                |
| Apr. 20 -  Apr. 23| Make cluster work with bignums, optimize sequential cluster searching                        |
| Apr. 24 - Apr. 26 | Add parallelization by moving prime cluster searching computation to GPU                     |
| Apr. 27 - Apr. 30 | Parallelize prime verification, improve algorithm by looking for further parallelism         |
| May 1 - May 3     | Implement complete miner                                                                     |
| May 4 - May 7     | Performance testing, final optimizations                                                     |
| May 8 - May 9     | Bug fixing, final write up                                                                   |&lt;/p&gt;

&lt;h1 id=&quot;demo&quot;&gt;Demo&lt;/h1&gt;
&lt;p&gt;For our final demo, we plan to run our miner across many of the GHC machines. We also plan to show graphs showing the speedup our miner achieved over the CPU miner.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Initial Proposal</title>
   <link href="http://www.tomshen.me/rustycoin/initial-proposal"/>
   <updated>2014-04-02T16:45:54-04:00</updated>
   <id>http://www.tomshen.me/rustycoin/initial-proposal</id>
   <content type="html">&lt;h1 id=&quot;summary&quot;&gt;Summary&lt;/h1&gt;
&lt;p&gt;The goal of this project is to create the first open source Riecoin GPU miner. We plan on first implementing a simple serial CPU version, based on David Andersen’s &lt;a href=&quot;https://github.com/dave-andersen/fastrie&quot;&gt;CPU miner&lt;/a&gt;. Then, we plan on parallelizing on a single machine using &lt;a href=&quot;https://github.com/luqmana/rust-opencl&quot;&gt;OpenCL&lt;/a&gt;. Finally, if we have time, we plan on parallelizing across multiple machines.&lt;/p&gt;

&lt;h1 id=&quot;background&quot;&gt;Background&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://riecoin.org&quot;&gt;Riecoin&lt;/a&gt; is a decentralized digital currency, similar to Bitcoin. It differs from Bitcoin in that its proof of work algorithm actually does something useful, rather than just check for sha256 collisions. In particular, the proof of work is based on finding a prime “constellation”: a sextuplet of “consecutive” prime numbers (a sequence of primes of the form &lt;em&gt;n, n+4, n+6, n+10, n+12, n+16&lt;/em&gt;). This prime constellation must be within a certain given range.&lt;/p&gt;

&lt;p&gt;Currently, there exists a parallel CPU miner for Riecoin, as we mentioned in the summary. However, it is a very naive implementation due to not sharing data between threads. Additionally, GPU miners for digital currencies tend to perform much better due to how parallelizable most proofs of work are. However, an open source GPU miner does not currently exist for Riecoin.&lt;/p&gt;

&lt;h1 id=&quot;challenge&quot;&gt;Challenge&lt;/h1&gt;
&lt;p&gt;The search range for the prime constellations starts at very large numbers: when Riecoin first launched, the target (start) number was 304-bits long, and the difficulty has been increasing ever since then. Additionally, since a new block is available every 2.5 minutes (and thus a new target number and limit), any miner must be able to search for and verify primality of large primes very quickly. This is where parallelization comes in.&lt;/p&gt;

&lt;p&gt;The current state-of-the-art miner uses &lt;a href=&quot;http://en.wikipedia.org/wiki/Wheel_factorization&quot;&gt;wheel factorization&lt;/a&gt; to find primes. Our primary challenge (after successfully implementing this algorithm sequentially) is to find places where we can improve on and parallelize this algorithm.&lt;/p&gt;

&lt;p&gt;Our main parallelization challenges are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Find candidate primes with sieving in parallel
    &lt;ul&gt;
      &lt;li&gt;Using OpenCL rather than CUDA because of better support&lt;/li&gt;
      &lt;li&gt;Sharing information rather than repeating computation (which is what currently is done in the CPU miner)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Check primality of candidate primes in parallel
    &lt;ul&gt;
      &lt;li&gt;Finding and implementing a primality test that will benefit from parallelization&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Parallelizing arbitrary-precision integer arithmetic
    &lt;ul&gt;
      &lt;li&gt;Difficult to correctly implement in parallel&lt;/li&gt;
      &lt;li&gt;Only if we have extra time&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;resources&quot;&gt;Resources&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt; - safe, concurrent systems programming language&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.khronos.org/opencl/&quot;&gt;OpenCL&lt;/a&gt; - GPU computation framework
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/luqmana/rust-opencl&quot;&gt;rust-opencl&lt;/a&gt; - OpenCL bindings for Rust&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/dave-andersen/fastrie&quot;&gt;fastrie&lt;/a&gt; - Riecoin CPU minter&lt;/li&gt;
  &lt;li&gt;David Andersen - both consulting with him in person and his blog posts (e.g. &lt;a href=&quot;http://da-data.blogspot.com/2014/03/fast-prime-cluster-search-or-building.html&quot;&gt;his post on fast prime cluster searching&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;GHC 3000 machines&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;goals--deliverables&quot;&gt;Goals &amp;amp; Deliverables&lt;/h1&gt;
&lt;p&gt;## Plan to achieve
* Implement a sequential Riecoin proof of work algorithm
* Use GPU for parallel prime cluster searching
* Achieve better performance than CPU miner on a GHC machine&lt;/p&gt;

&lt;h2 id=&quot;hope-to-achieve&quot;&gt;Hope to achieve&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Parallelize rest of computation (fast prime verification)&lt;/li&gt;
  &lt;li&gt;Implement complete Riecoin miner&lt;/li&gt;
  &lt;li&gt;Parallelize arbitrary-precision integer arithmetic&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;platform&quot;&gt;Platform&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;We plan to implement our miner in Rust, because it runs nearly as fast as C++ while also cleanly including many higher-level language features.&lt;/li&gt;
  &lt;li&gt;We will use OpenCL for GPU computation because there exists bindings for it in Rust (as opposed to CUDA).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;proposed-schedule&quot;&gt;Proposed Schedule&lt;/h1&gt;
&lt;p&gt;| Week              | What We Plan to Do                                                                           |
|——————-|———————————————————————————————-|
| Mar. 30 - Apr. 5  | Choose project idea, write initial proposal                                                  |
| Apr. 6 - Apr. 12  | Implement sequential, CPU-based proof of work algorithm                                      |
| Apr. 13 - Apr. 19 | Add parallelization by moving prime cluster searching computation to GPU, project checkpoint |
| Apr. 20 - Apr. 26 | Improve algorithm and look for more areas of parallelization, parallelize prime verification |
| Apr. 27 - May 3   | Implement complete miner                                                                     |
| May 4 - May 9     | Performance testing, bug fixing, final write up                                              |&lt;/p&gt;
</content>
 </entry>
 

</feed>
